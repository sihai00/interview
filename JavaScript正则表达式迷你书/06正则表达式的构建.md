# 第六章 正则表达式的构建
对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。不仅要看懂别人的解决方案，也要能独立地解决问题

## 1.构建正则前提
- 是否能使用正则：比如匹配这样的字符串:1010010001...
- 是否有必要使用正则：能用字符串 API 解决的简单问题，就不该正则出马
- 是否有必要构建一个复杂的正则

```javascript
// 密码匹配。要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符

var regex0 = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A- Z]))^[0-9A-Za-z]{6,12}$/;

function checkPassword (string) {
    var regex1 = /^[0-9A-Za-z]{6,12}$/;
    var regex2 = /^[0-9]{6,12}$/;
    var regex3 = /^[A-Z]{6,12}$/;
    var regex4 = /^[a-z]{6,12}$/;
    
    if (!regex1.test(string)) return false;
    if (regex2.test(string)) return false;
    if (regex3.test(string)) return false;
    if (regex4.test(string)) return false;
    return true;
}
```

## 2.准确性
准确性，就是能匹配预期的目标，并且不匹配非预期的目标

### 2.1 匹配固定电话
> 055188888888
> 0551-88888888
> (0551)88888888

1. 了解各部分的模式规则
    1. 区号是 "0" 开头的 3 到 4 位数字： `0\d{2,3}`
    2. 号码是非 "0" 开头的 7 到 8 位数字： `[1-9]\d{6,7}`
    3. 匹配 "055188888888" ： `/^0\d{2,3}[1-9]\d{6,7}$/`
    4. 匹配 "0551-88888888" ： `/^0\d{2,3}-[1-9]\d{6,7}$/`
    5. 匹配 "(0551)88888888" ： `/^\(0\d{2,3}\)[1-9]\d{6,7}$/`
2. 明确形式关系
    1. 或关系： `/^0\d{2,3}[1-9]\d{6,7}$|^0\d{2,3}-[1-9]\d{6,7}$|^\(0\d{2,3}\)[1-9]\d{6,7}$/`
3. 提取
    2. 提取公共部分： `/^(0\d{2,3}|0\d{2,3}-|\(0\d{2,3}\))[1-9]\d{6,7}$/`
    3. 简写：`/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/`

### 2.2 匹配浮点数
> 1.23、+1.23、-1.23 
> 10、+10、-10 
> .2、+.2、-.2

1. 了解各部分的模式规则
    1. 符号部分： `[+-]`
    2. 整数部分： `\d+`
    3. 小数部分： `\.\d+`
2. 明确形式关系
    1. 匹配 "1.23"、"+1.23"、"-1.23"： `/^[+-]?\d+\.\d+$/`
    2. 匹配 "10"、"+10"、"-10"： `/^[+-]?\d+$/`
    3. 匹配 ".2"、"+.2"、"-.2"： `/^[+-]?\.\d+$/`
3. 提取
    1. 公众部分： `/^[+-]?(\d+\.\d+|\d+|\.\d+)$/`

## 3.效率
正则表达式的运行分为如下的阶段：
1. 编译
2. 设定起始位置
3. 尝试匹配
4. 匹配失败的话，从下一位开始继续第 3 步
5. 最终结果：匹配成功或失败

```javascript
var regex = /\d+/g;
console.log( regex.lastIndex, regex.exec("123abc34def") );
console.log( regex.lastIndex, regex.exec("123abc34def") );
console.log( regex.lastIndex, regex.exec("123abc34def") );
console.log( regex.lastIndex, regex.exec("123abc34def") );
// => 0 ["123", index: 0, input: "123abc34def"]
// => 3 ["34", index: 6, input: "123abc34def"]
// => 8 null
// => 0 ["123", index: 0, input: "123abc34def"]
```

### 3.1 使用具体型字符组来代替通配符，来消除回溯
例如：匹配字符串 123"abc"456 中的 "abc"
- 正则：`/".*"/`
- 优化： `/"[^"]*"/`

### 3.2 使用非捕获型分组
因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。
当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组

例如，`/^[-]?(\d\.\d+|\d+|\.\d+)$/` 可以修改成：`/^[-]?(?:\d\.\d+|\d+|\.\d+)$/`

### 3.3 独立出确定字符
例如，`/a+/` 可以修改成 `/aa*/`

### 3.4 提取分支公共部分
比如，`/^abc|^def/` 修改成 `/^(?:abc|def)/`

### 3.5 减少分支的数量，缩小它们的范围
`/red|read/` 可以修改成 `/rea?d/`
此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的

## 参考
- [JavaScript正则表达式迷你书-第六章](https://github.com/qdlaoyao/js-regex-mini-book)
