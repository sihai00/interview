# 递归和回溯

| 方法 | 说明 | 题目 |
|:---:|:---:|:---:|
| 回溯 | 树形问题 | 17、93、131 |
| 回溯 | 排列问题 | 46、47 |
| 回溯 | 组合问题 | 77、39、40、216、78、90、401 |
| 回溯 | floodfilll | 200 |
| 回溯 | 回溯法 | 51 |

## 树形问题
```js
// 17. 电话号码的字母组合
// 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
// 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
// 示例:
// 输入："23"
// 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  var res = []
  var letterMap = {
    '2': 'abc',
    '3': 'def',
    '4': 'ghi',
    '5': 'jkl',
    '6': 'mno',
    '7': 'pqrs',
    '8': 'tuv',
    '9': 'wxyz'
  }
  
  if (!digits) return res 
  
  function findCombination(digits, index, s) {
    if (index === digits.length) {
      res.push(s)
      return 
    }
    
    var num = digits[index]
    var letters = letterMap[num]
    
    for (var i = 0; i < letters.length; i++) {
      findCombination(digits, index + 1, s + letters[i])
    }
    
    return 
  }
  
  findCombination(digits, 0, '')
  
  return res
};
```

## 排列问题
需要考虑组合的顺序问题
此经典问题需要去除已选的。例如：当选择了1后，递归下去的选项只有2和3
```js
// 46. 全排列
// 给定一个没有重复数字的序列，返回其所有可能的全排列。
// 示例:
// 输入: [1,2,3]
// 输出:
// [
//   [1,2,3],
//   [1,3,2],
//   [2,1,3],
//   [2,3,1],
//   [3,1,2],
//   [3,2,1]
// ]
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  var res = []
  var hash = []
  
  function helper(nums, index, p) {
    if (nums.length === index) {
      res.push(p)
      return 
    }
    
    for (var i = 0; i < nums.length; i++) {
      if (!hash[i]) {
        hash[i] = true
        helper(nums, index + 1, p.concat([nums[i]]))
        hash[i] = false
      } 
    } 
  }
  
  helper(nums, 0, [])
  
  return res
};
```

## 组合问题
不考虑组合中的顺序问题
```js
// 77. 组合
// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
// 示例:
// 输入: n = 4, k = 2
// 输出:
// [
//   [2,4],
//   [3,4],
//   [2,3],
//   [1,2],
//   [1,3],
//   [1,4],
// ]
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
  var res = []
  
  if (n <= 0 || k <= 0 || k > n) return []
  
  function helper(n, k, index, p) {
    if (p.length === k) {
      res.push(p)
      return 
    } 
    
    for (var i = index; i <= n; i++) {
      helper(n, k, i + 1, p.concat([i]))
    } 
  }  
  
  helper(n, k, 1, [])
  
  return res
};
```
