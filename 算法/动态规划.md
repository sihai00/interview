# 动态规划
在递归问题中，解决重叠子问题：
1. 记忆化搜索：自顶向下的解决问题
2. 动态规划：自底向上的解决问题

动态规划：将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题答案。

| 方法 | 说明 | 题目 |
|:---:|:---:|:---:|
| 递归、循环 | 记忆化搜索、动态规划 | [斐波那契数列](./fibonacci.js)、70、120、64、343、279、91、62、63、198、213、337、309 |
| 递归、循环 | 记忆化搜索、动态规划 | [0-1背包问题](./knapsack01.js) 、416、322、377、474、139、494|
| 递归、循环 | 记忆化搜索、动态规划 | [0-1背包问题](./knapsack01.js) 、416、322、377、474、139、494|
| 递归、循环 | LIS序列问题 | 300、376 |

## 1.斐波那契
```js
/**
 * 斐波那契数列
 * @param n
 * @returns number
 */
function fib(n){
  if (n === 0) return 0
  if (n === 1) return 1

  return fib(n - 1) + fib(n - 2)
}

/**
 * 斐波那契数列（自顶向下）
 * 缺点：大量重复的值反复计算
 * 优化：记忆化搜索，使用数组记忆计算过的值
 * @param n
 * @returns number
 */
function fib1(n) {
  // 记录重复值
  var memo = []

  function fib(n){
    if (n === 0) return 0
    if (n === 1) return 1

    if (!memo[n]) memo[n] = fib(n - 1) + fib(n - 2)

    return memo[n]
  }

  fib(n)

  return memo[n]
}

/**
 * 斐波那契数列（自底向上：动态规划）
 * @param n
 * @returns number
 */
function fib2(n) {
  var memo = []
  memo[0] = 0
  memo[1] = 1

  for (var i = 2; i <= n; i++) {
    memo[i] = memo[i - 1] + memo[i - 2]
  }

  return memo[n]
}
```
