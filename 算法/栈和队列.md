# 栈和队列

| 方法 | 说明 | 题目 |
|:---:|:---:|:---:|
| 栈 | 后进先出 | 20、150、71 |
| 栈 | 循环模拟递归 | 144、94、145、341 |
| 队列 | 先进先出 | 102、107、103、199 |
| 优先队列（堆） | 先进先出 | 347 |
| 图 | BFS和图的最短路径 | 279、127、126 |

## 栈
后进先出
```js
// 20. 有效的括号
// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
// 有效字符串需满足：
// 左括号必须用相同类型的右括号闭合。
// 左括号必须以正确的顺序闭合。
// 注意空字符串可被认为是有效字符串。
// 示例 1:
// 输入: "()"
// 输出: true
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  var stack = []
  
  for (var i = 0; i < s.length; i++) {
    var item = s[i]
    if (item === '(' || item === '{' || item === '[') {
      stack.push(item)
    } else {
      if (stack.length === 0) return false
      
      var c = stack.pop()
      var match = ''
      if (item === ')') {
        match = '('
      } else if(item === '}') {
        match = '{'
      } else {
        match = '['
      }
      
      if (c !== match) return false 
    }
  }  
  
  return stack.length > 0 ? false : true
};
```

循环模拟递归
```js
// 144. 二叉树的前序遍历
// 给定一个二叉树，返回它的 前序 遍历。
// 示例:
// 输入: [1,null,2,3]  
//    1
//     \
//      2
//     /
//    3 
// 输出: [1,2,3]
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
  if (root === null) return []
   var res = []
   var stack = [{type: 'go', node: root}]
   
   while(stack.length) {
      var top = stack.pop()
      
      if (top.type === 'print') {
        res.push(top.node)
      } else {
        if (top.node.right) stack.push({type: 'go', node: top.node.right}) 
        if (top.node.left) stack.push({type: 'go', node: top.node.left})
        stack.push({type: 'print', node: top.node.val}) 
      }
   }
   
   return res
};
var preorderTraversal = function(root) {
  var stack = []
  var res = []
  var cur = root
  
  while(cur || stack.length > 0) {
    while(cur) {
      res.push(cur.val)
      stack.push(cur)
      cur = cur.left
    }
    
    cur = stack.pop()
    cur = cur.right
  }
  
  return res
};
```
