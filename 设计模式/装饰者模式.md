# 装饰者模式
为函数（对象）动态增加职责，又不直接修改这个函数（对象）本身

```javascript
Function.prototype.before = function(beforefn){
    let _self = this;
    return function(){
        beforefn.apply(this, arguments);
        return _self.apply(this, arguments);
    }
}

Function.prototype.after = function(afterfn){
    let _self = this;
    return function(){
        let ret = _self.apply(this, arguments);
        afterfn.apply(this, arguments);
        return ret;
    }
}

let doSomething = function() {
  console.log(1);
}

doSomething = doSomething.before(() => {
    console.log(3);
}).after(() => {
    console.log(2);
});

doSomething();  // 输出 312
```

## 参考
[Mixin、多重继承与装饰者模式](https://github.com/youngwind/blog/issues/97)
