# 05内存控制
内存大小 = 堆大小 = 新生代 + 老年代。默认下，新生代 ( Young ) = 1/3 的堆空间大小，老年代 ( Old ) = 2/3 的堆空间大小
- 堆外内存：不是通过V8分配的内存
- V8堆内存的最大值：64位系统：1464 MB，32位系统：732 MB
  - 老生代（--max-old-space-size）：64位系统：1400 MB，32位系统：700 MB
  - 新生代（--max-new-space-size）：64位系统：16 MB，32位系统：8 MB

## V8垃圾回收
### Scavenge算法
适合新生代。采用复制的方式实现的垃圾回收算法
1. 堆内存一分为二，一个处于使用中（Form空间），另一个处于闲置状态（To空间）
2. 当我们分配对象时，在From空间中进行分配
3. 当开始进行垃圾回收时，存活对象将被复制到To空间，非存活对象占用的空间将会被释放
4. 完成复制后，From空间和To空间的角色发生对换

缺点：
- 只能使用堆内存中的一半

优点：
- 时间效率高，空间换时间

对象晋升：新生代 -> 老生代
- 对象是否经历过Scavenge回收（经历过一次）
- To空间的内存占用比超过限制（To空间已经使用了超过25%）

### Mark-Sweep 标记清除 & Mark-Compact 标记整理
- Mark-Sweep：标记清除
  - 思想：标记死亡对象，进行清除
  - 缺点：空间不连续。导致不能分配大内存
- Mark-Compact：标记整理
  - 思想：标记死亡对象，整理活着对象到一端，清除死亡对象
  - 优点：解决Mark-Sweep不能分配大内存问题
  - 缺点：移动需要时间
- V8策略：主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact

### Incremental Marking 增量标记
避免出现JavaScript应用逻辑与垃圾回收器不同步，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”

- 新生代：新生代小，影响不大
- 老生代：增量标记。切片标记和清除

## 内存指标
- process.memoryUsage：Node进程的内存占用情况
  - rss：进程的常驻内存部分
  - heapTotal：堆中总共申请的内存量
  - heapUsed：目前堆中使用中的内存量
- os.totalmem：系统的总内存
- os.freemem：闲置内存

## 内存泄漏
- 缓存（老生代）：例如一个对象
- 队列消费不及时
- 作用域未释放

缓存限制策略：
1. 限制健值
2. 模块机制
3. 进程外缓存。如Redis和Memcached